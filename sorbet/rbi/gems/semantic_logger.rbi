# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/semantic_logger/all/semantic_logger.rbi
#
# semantic_logger-4.5.0
class Thread
end
module SemanticLogger
  def self.[](klass); end
  def self.add_appender(options, deprecated_level = nil, &block); end
  def self.add_signal_handler(log_level_signal = nil, thread_dump_signal = nil, gc_log_microseconds = nil); end
  def self.appenders; end
  def self.application; end
  def self.application=(application); end
  def self.backtrace_level; end
  def self.backtrace_level=(level); end
  def self.backtrace_level_index; end
  def self.close; end
  def self.default_level; end
  def self.default_level=(level); end
  def self.default_level_index; end
  def self.fast_tag(tag); end
  def self.flush; end
  def self.host; end
  def self.host=(host); end
  def self.lag_check_interval; end
  def self.lag_check_interval=(lag_check_interval); end
  def self.lag_threshold_s; end
  def self.named_tagged(hash); end
  def self.named_tags; end
  def self.on_log(object = nil, &block); end
  def self.pop_named_tags(quantity = nil); end
  def self.pop_tags(quantity = nil); end
  def self.push_named_tags(hash); end
  def self.push_tags(*tags); end
  def self.queue_size; end
  def self.remove_appender(appender); end
  def self.reopen; end
  def self.silence(new_level = nil); end
  def self.tagged(*tags, &block); end
  def self.tags; end
end
module SemanticLogger::Levels
  def self.index(level); end
  def self.level(level_index); end
end
module SemanticLogger::Concerns
end
module SemanticLogger::Metric
end
module SemanticLogger::Reporters
end
class SemanticLogger::Base
  def backtrace(thread: nil, level: nil, message: nil, payload: nil, metric: nil, metric_amount: nil); end
  def benchmark(level, message, params = nil, &block); end
  def benchmark_debug(message, params = nil, &block); end
  def benchmark_error(message, params = nil, &block); end
  def benchmark_fatal(message, params = nil, &block); end
  def benchmark_info(message, params = nil, &block); end
  def benchmark_trace(message, params = nil, &block); end
  def benchmark_warn(message, params = nil, &block); end
  def debug(message = nil, payload = nil, exception = nil, &block); end
  def debug?; end
  def error(message = nil, payload = nil, exception = nil, &block); end
  def error?; end
  def fast_tag(tag, &block); end
  def fatal(message = nil, payload = nil, exception = nil, &block); end
  def fatal?; end
  def filter; end
  def filter=(arg0); end
  def filtered?(log); end
  def info(message = nil, payload = nil, exception = nil, &block); end
  def info?; end
  def initialize(klass, level = nil, filter = nil); end
  def level; end
  def level=(level); end
  def level_index; end
  def log(_log_); end
  def log_internal(level, index, message = nil, payload = nil, exception = nil, &block); end
  def measure(level, message, params = nil, &block); end
  def measure_debug(message, params = nil, &block); end
  def measure_error(message, params = nil, &block); end
  def measure_fatal(message, params = nil, &block); end
  def measure_info(message, params = nil, &block); end
  def measure_internal(level, index, message, params); end
  def measure_method(index:, level:, message:, min_duration:, metric:, log_exception:, on_exception_level:); end
  def measure_trace(message, params = nil, &block); end
  def measure_warn(message, params = nil, &block); end
  def meets_log_level?(log); end
  def name; end
  def name=(arg0); end
  def named_tags; end
  def payload; end
  def pop_tags(quantity = nil); end
  def push_tags(*tags); end
  def should_log?(log); end
  def silence(new_level = nil, &block); end
  def tagged(*tags, &block); end
  def tags; end
  def trace(message = nil, payload = nil, exception = nil, &block); end
  def trace?; end
  def warn(message = nil, payload = nil, exception = nil, &block); end
  def warn?; end
  def with_payload(payload, &block); end
  def with_tags(*tags, &block); end
end
module SemanticLogger::Concerns::Compatibility
  def add(severity, message = nil, progname = nil, &block); end
  def close; end
  def reopen(logdev = nil); end
  def self.included(base); end
end
module SemanticLogger::AnsiColors
end
module SemanticLogger::Appender
  def self.build(options, &block); end
  def self.colorized_formatter; end
  def self.factory(options, &block); end
  def self.json_formatter; end
end
class SemanticLogger::Appender::Async
  def active?; end
  def appender; end
  def application(*args, &block); end
  def capped?; end
  def check_lag(log); end
  def close; end
  def create_queue; end
  def filter(*args, &block); end
  def flush; end
  def host(*args, &block); end
  def initialize(appender:, max_queue_size: nil, lag_check_interval: nil, lag_threshold_s: nil); end
  def lag_check_interval; end
  def lag_check_interval=(arg0); end
  def lag_threshold_s; end
  def lag_threshold_s=(arg0); end
  def level(*args, &block); end
  def level=(*args, &block); end
  def log(log); end
  def logger(*args, &block); end
  def logger=(*args, &block); end
  def max_queue_size; end
  def name(*args, &block); end
  def process; end
  def process_message(message); end
  def process_messages; end
  def queue; end
  def reopen; end
  def should_log?(*args, &block); end
  def submit_request(command); end
  def thread; end
  extend Forwardable
end
class SemanticLogger::Processor < SemanticLogger::Appender::Async
  def appenders; end
  def initialize(max_queue_size: nil); end
  def self.logger; end
  def self.logger=(arg0); end
  def start; end
end
class SemanticLogger::Appenders < Concurrent::Array
  def add(options, deprecated_level = nil, &block); end
  def close; end
  def convert_old_appender_args(appender, level); end
  def flush; end
  def initialize(logger = nil); end
  def log(log); end
  def logger; end
  def logger=(arg0); end
  def reopen; end
end
class SemanticLogger::Subscriber < SemanticLogger::Base
  def application; end
  def application=(arg0); end
  def close; end
  def default_formatter; end
  def flush; end
  def formatter; end
  def formatter=(formatter); end
  def host; end
  def host=(arg0); end
  def initialize(level: nil, formatter: nil, filter: nil, application: nil, host: nil, metrics: nil, &block); end
  def level; end
  def level_index; end
  def logger; end
  def logger=(arg0); end
  def metrics=(arg0); end
  def metrics?; end
  def should_log?(log); end
end
class SemanticLogger::Appender::File < SemanticLogger::Subscriber
  def flush; end
  def initialize(io: nil, file_name: nil, **args, &block); end
  def log(log); end
  def reopen; end
end
module SemanticLogger::Formatters
  def self.factory(formatter); end
end
class SemanticLogger::Formatters::Base
  def format_time(time); end
  def initialize(time_format: nil, log_host: nil, log_application: nil, precision: nil); end
  def log_application; end
  def log_application=(arg0); end
  def log_host; end
  def log_host=(arg0); end
  def precision; end
  def precision=(arg0); end
  def self.build_time_format(precision = nil); end
  def time; end
  def time_format; end
  def time_format=(arg0); end
end
class SemanticLogger::Formatters::Default < SemanticLogger::Formatters::Base
  def call(log, logger); end
  def duration; end
  def exception; end
  def level; end
  def log; end
  def log=(arg0); end
  def logger; end
  def logger=(arg0); end
  def message; end
  def name; end
  def named_tags; end
  def payload; end
  def process_info; end
  def tags; end
end
class SemanticLogger::Logger < SemanticLogger::Base
  def <<(message = nil, payload = nil, exception = nil, &block); end
  def datetime_format; end
  def datetime_format=(arg0); end
  def formatter; end
  def formatter=(arg0); end
  def initialize(klass, level = nil, filter = nil); end
  def log(log, message = nil, progname = nil, &block); end
  def progname; end
  def progname=(arg0); end
  def self.call_subscribers(log); end
  def self.processor; end
  def self.subscribe(object = nil, &block); end
  def self.subscribers; end
  def sev_threshold; end
  def sev_threshold=(level); end
  def silence_logger(new_level = nil, &block); end
  def unknown(message = nil, payload = nil, exception = nil, &block); end
  def unknown?; end
  include SemanticLogger::Concerns::Compatibility
end
