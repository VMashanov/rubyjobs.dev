# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rollbar/all/rollbar.rbi
#
# rollbar-2.20.2
module Rollbar
  def self.clear_notifier!; end
  def self.configuration; end
  def self.configure(&block); end
  def self.critical(*args, &block); end
  def self.debug(*args, &block); end
  def self.error(*args, &block); end
  def self.info(*args, &block); end
  def self.last_report; end
  def self.last_report=(report); end
  def self.log(*args, &block); end
  def self.log_debug(*args, &block); end
  def self.log_error(*args, &block); end
  def self.log_info(*args, &block); end
  def self.log_warning(*args, &block); end
  def self.logger(*args, &block); end
  def self.notifier; end
  def self.notifier=(notifier); end
  def self.plugins; end
  def self.plugins=(arg0); end
  def self.preconfigure(&block); end
  def self.process_from_async_handler(*args, &block); end
  def self.process_item(*args, &block); end
  def self.reconfigure(&block); end
  def self.report_exception(exception, request_data = nil, person_data = nil, level = nil); end
  def self.report_message(message, level = nil, extra_data = nil); end
  def self.report_message_with_request(message, level = nil, request_data = nil, person_data = nil, extra_data = nil); end
  def self.reset_notifier!; end
  def self.root_notifier; end
  def self.root_notifier=(arg0); end
  def self.safely?; end
  def self.scope!(options = nil); end
  def self.scope(*args, &block); end
  def self.scope_object(*args, &block); end
  def self.scoped(options = nil, config_overrides = nil); end
  def self.send_failsafe(*args, &block); end
  def self.silenced(*args, &block); end
  def self.unconfigure; end
  def self.warn(*args, &block); end
  def self.warning(*args, &block); end
  def self.with_config(overrides, &block); end
end
class Rollbar::Plugin
  def callables; end
  def configuration; end
  def dependencies; end
  def dependencies_satisfy?; end
  def dependency(&block); end
  def execute!; end
  def execute(&block); end
  def initialize(name); end
  def load!; end
  def load?; end
  def load_on_demand; end
  def load_scoped!(transparent = nil); end
  def loaded; end
  def loaded=(arg0); end
  def log_loading_error(error); end
  def log_unloading_error(error); end
  def name; end
  def on_demand; end
  def on_demand=(arg0); end
  def require_dependency(file); end
  def revert(&block); end
  def revert_callables; end
  def unload!; end
end
class Rollbar::Plugins
  def collection; end
  def define(name, &block); end
  def get(name); end
  def initialize; end
  def load!; end
  def loaded?(name); end
  def plugin_files; end
  def require_all; end
end
class Rollbar::Configuration
  def [](option); end
  def access_token; end
  def access_token=(arg0); end
  def anonymize_user_ip; end
  def anonymize_user_ip=(arg0); end
  def async_handler; end
  def async_handler=(arg0); end
  def before_process; end
  def before_process=(*handler); end
  def branch; end
  def branch=(arg0); end
  def capture_uncaught; end
  def capture_uncaught=(arg0); end
  def code_version; end
  def code_version=(arg0); end
  def collect_user_ip; end
  def collect_user_ip=(arg0); end
  def custom_data_method; end
  def custom_data_method=(arg0); end
  def default_logger; end
  def default_logger=(arg0); end
  def delayed_job_enabled; end
  def delayed_job_enabled=(arg0); end
  def disable_core_monkey_patch; end
  def disable_core_monkey_patch=(arg0); end
  def disable_monkey_patch; end
  def disable_monkey_patch=(arg0); end
  def disable_rack_monkey_patch; end
  def disable_rack_monkey_patch=(arg0); end
  def dj_threshold; end
  def dj_threshold=(arg0); end
  def enabled; end
  def enabled=(arg0); end
  def endpoint; end
  def endpoint=(arg0); end
  def environment; end
  def environment=(arg0); end
  def exception_level_filters; end
  def exception_level_filters=(arg0); end
  def execute_hook(symbol, *args); end
  def failover_handlers; end
  def failover_handlers=(arg0); end
  def filepath; end
  def filepath=(arg0); end
  def framework; end
  def framework=(arg0); end
  def hook(symbol, &block); end
  def host; end
  def host=(arg0); end
  def ignored_person_ids; end
  def ignored_person_ids=(arg0); end
  def initialize; end
  def initialize_copy(orig); end
  def js_enabled; end
  def js_enabled=(arg0); end
  def js_options; end
  def js_options=(arg0); end
  def locals; end
  def locals=(arg0); end
  def log_payload; end
  def log_payload=(arg0); end
  def logger; end
  def logger=(arg0); end
  def logger_level; end
  def logger_level=(level); end
  def merge!(options); end
  def merge(options); end
  def net_retries; end
  def net_retries=(arg0); end
  def open_timeout; end
  def open_timeout=(arg0); end
  def payload_options; end
  def payload_options=(arg0); end
  def person_email_method; end
  def person_email_method=(arg0); end
  def person_id_method; end
  def person_id_method=(arg0); end
  def person_method; end
  def person_method=(arg0); end
  def person_username_method; end
  def person_username_method=(arg0); end
  def populate_empty_backtraces; end
  def populate_empty_backtraces=(arg0); end
  def project_gem_paths; end
  def project_gems=(gems); end
  def proxy; end
  def proxy=(arg0); end
  def raise_on_error; end
  def raise_on_error=(arg0); end
  def randomize_scrub_length; end
  def randomize_scrub_length=(arg0); end
  def report_dj_data; end
  def report_dj_data=(arg0); end
  def request_timeout; end
  def request_timeout=(arg0); end
  def root; end
  def root=(arg0); end
  def safely; end
  def safely=(arg0); end
  def safely?; end
  def scrub_fields; end
  def scrub_fields=(arg0); end
  def scrub_headers; end
  def scrub_headers=(arg0); end
  def scrub_password; end
  def scrub_password=(arg0); end
  def scrub_user; end
  def scrub_user=(arg0); end
  def scrub_whitelist; end
  def scrub_whitelist=(arg0); end
  def send_extra_frame_data; end
  def send_extra_frame_data=(value); end
  def sidekiq_threshold; end
  def sidekiq_threshold=(arg0); end
  def transform; end
  def transform=(*handler); end
  def transmit; end
  def transmit=(arg0); end
  def uncaught_exception_level; end
  def uncaught_exception_level=(arg0); end
  def use_active_job(options = nil); end
  def use_async; end
  def use_async=(arg0); end
  def use_delayed_job(options = nil); end
  def use_eventmachine; end
  def use_eventmachine=(value); end
  def use_exception_level_filters_default; end
  def use_exception_level_filters_default=(arg0); end
  def use_resque(options = nil); end
  def use_shoryuken(options = nil); end
  def use_sidekiq(options = nil); end
  def use_sidekiq=(value); end
  def use_sucker_punch; end
  def use_sucker_punch=(_value); end
  def use_thread; end
  def user_ip_obfuscator_secret; end
  def user_ip_obfuscator_secret=(arg0); end
  def verify_ssl_peer; end
  def verify_ssl_peer=(arg0); end
  def web_base; end
  def web_base=(arg0); end
  def write_to_file; end
  def write_to_file=(arg0); end
end
class Rollbar::LoggerProxy
  def acceptable_levels; end
  def debug(message); end
  def error(message); end
  def info(message); end
  def initialize(object); end
  def log(level, message); end
  def object; end
  def warn(message); end
end
class Rollbar::Ignore < StandardError
end
class Rollbar::LazyStore
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def clone; end
  def data; end
  def eql?(other); end
  def find_value(key); end
  def initialize(initial_data); end
  def load_value(key); end
  def loaded_data; end
  def method_missing(method_sym, *args, &block); end
  def raw; end
  def respond_to?(method_sym); end
end
module Rollbar::Util
  def self.clone_obj(obj); end
  def self.count_method_in_stack(method_symbol, file_path = nil); end
  def self.deep_copy(obj, copied = nil); end
  def self.deep_merge(hash1, hash2, merged = nil); end
  def self.enforce_valid_utf8(payload); end
  def self.iterate_and_update(obj, block, seen = nil); end
  def self.iterate_and_update_array(array, block, seen); end
  def self.iterate_and_update_hash(obj, block, seen); end
  def self.method_in_stack(method_symbol, file_path = nil); end
  def self.method_in_stack_twice(method_symbol, file_path = nil); end
  def self.perform_deep_merge(hash1, hash2, merged); end
  def self.truncate(str, length); end
  def self.uuid_rollbar_url(data, configuration); end
end
module Rollbar::Util::Hash
  def self.deep_stringify_keys(hash, seen = nil); end
  def self.map_value(thing, meth, seen); end
end
module Rollbar::JSON
  def adapter_options; end
  def detect_multi_json_adapter; end
  def dump(object); end
  def find_options_module; end
  def load(string); end
  def multi_json_adapter_module_name; end
  def options_module; end
  def options_module=(arg0); end
  def with_adapter(&block); end
  extend Rollbar::JSON
end
module Rollbar::JSON::Oj
  def options; end
  def self.options; end
end
module Rollbar::JSON::Default
  def options; end
  def self.options; end
end
module Rollbar::LanguageSupport
  def const_defined?(mod, target, inherit = nil); end
  def const_get(mod, target, inherit = nil); end
  def ruby_19?; end
  def self.const_defined?(mod, target, inherit = nil); end
  def self.const_get(mod, target, inherit = nil); end
  def self.ruby_19?; end
  def self.timeout_exceptions; end
  def self.version?(version); end
  def timeout_exceptions; end
  def version?(version); end
end
module Rollbar::Delay
end
class Rollbar::Delay::GirlFriday
  def call(payload); end
  def self.call(payload); end
  def self.queue; end
  def self.queue_class; end
end
class Rollbar::Delay::Thread
  def call(payload); end
  def self.build_reaper_thread; end
  def self.call(payload); end
  def self.configure_exit_handler; end
  def self.reaper; end
  def self.spawn_threads_reaper; end
  def self.threads; end
end
class Rollbar::Delay::Thread::Error < StandardError
end
class Rollbar::Delay::Thread::TimeoutError < Rollbar::Delay::Thread::Error
end
module Rollbar::Scrubbers
  def random_filtered_value; end
  def scrub_value(value); end
  def self.random_filtered_value; end
  def self.scrub_value(value); end
end
class Rollbar::Scrubbers::Params
  def attachment_value(value); end
  def build_fields_regex(config, extra_fields); end
  def build_scrub_options(config, extra_fields, whitelist); end
  def build_whitelist_regex(whitelist); end
  def call(options = nil); end
  def rollbar_filtered_param_value(value); end
  def scrub(params, options); end
  def scrub_array(array, options); end
  def scrub_value(value); end
  def self.call(*args); end
  def skip_value?(value); end
end
class Rollbar::Item
  def [](*args, &block); end
  def build; end
  def build_backtrace_body; end
  def build_body; end
  def build_data; end
  def build_environment; end
  def build_extra; end
  def build_message_body; end
  def configuration; end
  def context; end
  def custom_data; end
  def custom_data_method?; end
  def dump; end
  def enforce_valid_utf8; end
  def exception; end
  def extra; end
  def handle_too_large_payload(stringified_payload, final_payload, attempts); end
  def ignored?; end
  def initialize(options); end
  def level; end
  def logger; end
  def message; end
  def notifier; end
  def payload; end
  def payload=(arg0); end
  def report_custom_data_error(e); end
  def scope; end
  def scrub(data); end
  def self.build_with(payload, options = nil); end
  def server_data; end
  def too_large_payload_string(attempts); end
  def transform; end
  def transform_options; end
  extend Forwardable
end
class Rollbar::Item::Locals
  def self.exception_frames; end
  def self.frame_for_location(filename, lineno); end
  def self.locals_for(frame); end
  def self.locals_for_location(filename, lineno); end
  def self.matching_frame?(frame, filename, lineno); end
  def self.prepare_value(value); end
  def self.scrub(hash); end
end
class Rollbar::Item::Frame
  def backtrace; end
  def code_data(file_lines, lineno); end
  def configuration; end
  def context_data(file_lines, lineno); end
  def extra_frame_data(filename, lineno); end
  def frame; end
  def initialize(backtrace, frame, options = nil); end
  def locals_data(filename, lineno); end
  def outside_project?(filename); end
  def post_data(file_lines, lineno); end
  def pre_data(file_lines, lineno); end
  def skip_extra_frame_data?(filename, file_lines); end
  def to_h; end
  def unknown_frame; end
end
class Rollbar::Item::Backtrace
  def build; end
  def configuration; end
  def exception; end
  def exception_backtrace(current_exception); end
  def extra; end
  def files; end
  def get_file_lines(filename); end
  def initialize(exception, options = nil); end
  def map_frames(current_exception); end
  def message; end
  def read_file(filename); end
  def rollbar_lib_gem_dir; end
  def to_h; end
  def trace_chain; end
  def trace_data(current_exception); end
end
module Rollbar::Encoding
  def self.encode(object); end
  def self.encoding_class; end
  def self.encoding_class=(arg0); end
  def self.setup; end
end
class Rollbar::Encoding::Encoder
  def detect_encoding(v); end
  def encode; end
  def encoding_args(value); end
  def force_encoding(value); end
  def initialize(object); end
  def object; end
  def object=(arg0); end
end
module Rollbar::Truncation
  def self.truncate(payload, attempts = nil); end
  extend Rollbar::Truncation::Mixin
end
module Rollbar::Truncation::Mixin
  def dump(payload); end
  def select_frames(frames, range = nil); end
  def truncate?(result); end
end
class Rollbar::Truncation::RawStrategy
  def call(payload); end
  def self.call(payload); end
  include Rollbar::Truncation::Mixin
end
class Rollbar::Truncation::FramesStrategy
  def call(payload); end
  def self.call(payload); end
  def truncate_trace(body); end
  def truncate_trace_chain(body); end
  include Rollbar::Truncation::Mixin
end
class Rollbar::Truncation::StringsStrategy
  def call(payload); end
  def self.call(payload); end
  def truncate_strings_proc(threshold); end
  include Rollbar::Truncation::Mixin
end
class Rollbar::Truncation::MinBodyStrategy
  def call(payload); end
  def self.call(payload); end
  def truncate_trace_data(trace_data); end
  include Rollbar::Truncation::Mixin
end
class Rollbar::Truncation::RemoveRequestStrategy
  def call(payload); end
  def self.call(payload); end
  include Rollbar::Truncation::Mixin
end
class Rollbar::Truncation::RemoveExtraStrategy
  def call(payload); end
  def delete_message_extra(body); end
  def delete_trace_chain_extra(body); end
  def delete_trace_extra(body); end
  def self.call(payload); end
  include Rollbar::Truncation::Mixin
end
class Rollbar::Notifier
  def async_failover(item); end
  def build_item(level, message, exception, extra, context); end
  def call_before_process(options); end
  def configuration; end
  def configuration=(arg0); end
  def configure; end
  def critical(*args); end
  def current_bindings; end
  def debug(*args); end
  def default_async_handler; end
  def disable_locals; end
  def do_post(uri, body, access_token); end
  def do_write_item(item); end
  def enable_locals; end
  def enable_locals?; end
  def enabled?; end
  def error(*args); end
  def exception_bindings; end
  def extract_arguments(args); end
  def failsafe_body(reason); end
  def failsafe_reason(message, exception); end
  def filtered_level(exception); end
  def handle_net_retries; end
  def handle_response(response); end
  def http_proxy(uri); end
  def http_proxy_for_em(uri); end
  def ignored?(exception, use_exception_level_filters = nil); end
  def info(*args); end
  def initialize(parent_notifier = nil, payload_options = nil, scope = nil); end
  def last_report; end
  def last_report=(arg0); end
  def log(level, *args); end
  def log_and_return_item_data(item); end
  def log_data(data); end
  def log_debug(message); end
  def log_error(message); end
  def log_info(message); end
  def log_instance_link(data); end
  def log_warn(message); end
  def log_warning(message); end
  def logger; end
  def lookup_exception_level(orig_level, exception, use_exception_level_filters); end
  def multibyte?(str); end
  def null_proxy; end
  def pack_ruby260_bytes(body); end
  def preconfigure; end
  def process_async_item(item); end
  def process_from_async_handler(payload); end
  def process_item(item); end
  def proxy_from_config; end
  def proxy_from_env(uri); end
  def reconfigure; end
  def report(level, message, exception, extra, context); end
  def report_internal_error(exception); end
  def report_with_rescue(level, message, exception, extra, context); end
  def reset!; end
  def safely; end
  def schedule_item(item); end
  def scope!(options = nil, config_overrides = nil); end
  def scope(scope_overrides = nil, config_overrides = nil); end
  def scope_object; end
  def scope_object=(arg0); end
  def send_failsafe(message, exception, uuid = nil, host = nil); end
  def send_item(item); end
  def send_item_using_eventmachine(item, uri); end
  def silenced; end
  def skip_retries?; end
  def ssl_verify_mode; end
  def trace_with_bindings; end
  def unconfigure; end
  def use_exception_level_filters?(options); end
  def warn(*args); end
  def warning(*args); end
  def write_item(item); end
end
class Rollbar::Notifier::TraceWithBindings
  def detect_reraise(trace); end
  def disable; end
  def enable; end
  def exception_frames; end
  def exception_signature(trace); end
  def frame(trace); end
  def frames; end
  def initialize; end
  def reset; end
  def trace_point; end
end
module Rollbar::Rake
  def self.patch!; end
  def self.patch?; end
  def self.patched; end
  def self.patched=(arg0); end
  def self.patched?; end
  def self.rake_version; end
  def self.skip_patch; end
end
module Rollbar::Rake::Handler
  def display_error_message_with_rollbar(ex); end
  def self.included(base); end
end
module Rollbar::ActiveJob
  def self.included(base); end
end
