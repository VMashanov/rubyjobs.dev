# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rouge/all/rouge.rbi
#
# rouge-1.11.1
module Rouge
  def self.highlight(text, lexer, formatter, &b); end
  def self.version; end
end
class Rouge::InheritableHash < Hash
  def [](k); end
  def each(&b); end
  def include?(k); end
  def initialize(parent = nil); end
  def keys; end
  def own_keys; end
  def parent; end
end
class Rouge::InheritableList
  def <<(o); end
  def each(&b); end
  def initialize(parent = nil); end
  def own_entries; end
  def parent; end
  def push(o); end
  include Enumerable
end
module Rouge::Indentation
  def indentation(indent_str); end
  def reset!; end
  def starts_block(block_state); end
end
class Rouge::TextAnalyzer < String
  def doctype; end
  def doctype?(type = nil); end
  def lexes_cleanly?(lexer); end
  def shebang; end
  def shebang?(match); end
end
class Rouge::Token
  def self.[](qualname); end
  def self.cache; end
  def self.each_token(&b); end
  def self.inspect; end
  def self.make_token(name, shortname, &b); end
  def self.matches?(other); end
  def self.name; end
  def self.parent; end
  def self.qualname; end
  def self.register!; end
  def self.shortname; end
  def self.sub_tokens; end
  def self.token(name, shortname, &b); end
  def self.token_chain; end
end
module Rouge::Token::Tokens
  def self.token(name, shortname, &b); end
end
class Rouge::Token::Tokens::Text::Whitespace < Rouge::Token::Tokens::Text
end
class Rouge::Token::Tokens::Text < Rouge::Token
end
class Rouge::Token::Tokens::Error < Rouge::Token
end
class Rouge::Token::Tokens::Other < Rouge::Token
end
class Rouge::Token::Tokens::Keyword::Constant < Rouge::Token::Tokens::Keyword
end
class Rouge::Token::Tokens::Keyword::Declaration < Rouge::Token::Tokens::Keyword
end
class Rouge::Token::Tokens::Keyword::Namespace < Rouge::Token::Tokens::Keyword
end
class Rouge::Token::Tokens::Keyword::Pseudo < Rouge::Token::Tokens::Keyword
end
class Rouge::Token::Tokens::Keyword::Reserved < Rouge::Token::Tokens::Keyword
end
class Rouge::Token::Tokens::Keyword::Type < Rouge::Token::Tokens::Keyword
end
class Rouge::Token::Tokens::Keyword::Variable < Rouge::Token::Tokens::Keyword
end
class Rouge::Token::Tokens::Keyword < Rouge::Token
end
class Rouge::Token::Tokens::Name::Attribute < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Builtin::Pseudo < Rouge::Token::Tokens::Name::Builtin
end
class Rouge::Token::Tokens::Name::Builtin < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Class < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Constant < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Decorator < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Entity < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Exception < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Function < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Property < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Label < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Namespace < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Other < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Tag < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name::Variable::Class < Rouge::Token::Tokens::Name::Variable
end
class Rouge::Token::Tokens::Name::Variable::Global < Rouge::Token::Tokens::Name::Variable
end
class Rouge::Token::Tokens::Name::Variable::Instance < Rouge::Token::Tokens::Name::Variable
end
class Rouge::Token::Tokens::Name::Variable < Rouge::Token::Tokens::Name
end
class Rouge::Token::Tokens::Name < Rouge::Token
end
class Rouge::Token::Tokens::Literal::Date < Rouge::Token::Tokens::Literal
end
class Rouge::Token::Tokens::Str::Backtick < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Char < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Doc < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Double < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Escape < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Heredoc < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Interpol < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Other < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Regex < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Single < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str::Symbol < Rouge::Token::Tokens::Str
end
class Rouge::Token::Tokens::Str < Rouge::Token::Tokens::Literal
end
class Rouge::Token::Tokens::Num::Float < Rouge::Token::Tokens::Num
end
class Rouge::Token::Tokens::Num::Hex < Rouge::Token::Tokens::Num
end
class Rouge::Token::Tokens::Num::Integer::Long < Rouge::Token::Tokens::Num::Integer
end
class Rouge::Token::Tokens::Num::Integer < Rouge::Token::Tokens::Num
end
class Rouge::Token::Tokens::Num::Oct < Rouge::Token::Tokens::Num
end
class Rouge::Token::Tokens::Num::Bin < Rouge::Token::Tokens::Num
end
class Rouge::Token::Tokens::Num::Other < Rouge::Token::Tokens::Num
end
class Rouge::Token::Tokens::Num < Rouge::Token::Tokens::Literal
end
class Rouge::Token::Tokens::Literal < Rouge::Token
end
class Rouge::Token::Tokens::Operator::Word < Rouge::Token::Tokens::Operator
end
class Rouge::Token::Tokens::Operator < Rouge::Token
end
class Rouge::Token::Tokens::Punctuation::Indicator < Rouge::Token::Tokens::Punctuation
end
class Rouge::Token::Tokens::Punctuation < Rouge::Token
end
class Rouge::Token::Tokens::Comment::Doc < Rouge::Token::Tokens::Comment
end
class Rouge::Token::Tokens::Comment::Multiline < Rouge::Token::Tokens::Comment
end
class Rouge::Token::Tokens::Comment::Preproc < Rouge::Token::Tokens::Comment
end
class Rouge::Token::Tokens::Comment::Single < Rouge::Token::Tokens::Comment
end
class Rouge::Token::Tokens::Comment::Special < Rouge::Token::Tokens::Comment
end
class Rouge::Token::Tokens::Comment < Rouge::Token
end
class Rouge::Token::Tokens::Generic::Deleted < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Emph < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Error < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Heading < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Inserted < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Output < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Prompt < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Strong < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Subheading < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Traceback < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic::Lineno < Rouge::Token::Tokens::Generic
end
class Rouge::Token::Tokens::Generic < Rouge::Token
end
class Rouge::Guesser
  def collect_best(lexers, opts = nil, &scorer); end
  def filter(lexers); end
  def self.guess(guessers, lexers); end
end
module Rouge::Guessers
end
class Rouge::Guessers::GlobMapping < Rouge::Guesser
  def filename; end
  def filter(lexers); end
  def glob_map; end
  def initialize(glob_map, filename); end
  def self.by_pairs(mapping, filename); end
  def test_pattern(pattern, path); end
end
class Rouge::Guessers::Modeline < Rouge::Guesser
  def filter(lexers); end
  def initialize(source, opts = nil); end
end
class Rouge::Guessers::Filename < Rouge::Guesser
  def filter(lexers); end
  def fname; end
  def initialize(filename); end
end
class Rouge::Guessers::Mimetype < Rouge::Guesser
  def filter(lexers); end
  def initialize(mimetype); end
  def mimetype; end
end
class Rouge::Guessers::Source < Rouge::Guesser
  def filter(lexers); end
  def initialize(source); end
  def source; end
end
class Rouge::Lexer
  def debug; end
  def initialize(opts = nil); end
  def lex(string, opts = nil, &b); end
  def option(k, v = nil); end
  def options(o = nil); end
  def reset!; end
  def self.aliases(*args); end
  def self.all; end
  def self.analyze_text(text); end
  def self.assert_utf8!(str); end
  def self.default_options(o = nil); end
  def self.demo(arg = nil); end
  def self.demo_file(arg = nil); end
  def self.desc(arg = nil); end
  def self.filenames(*fnames); end
  def self.find(name); end
  def self.find_fancy(str, code = nil); end
  def self.guess(info = nil); end
  def self.guess_by_filename(fname); end
  def self.guess_by_mimetype(mt); end
  def self.guess_by_source(source); end
  def self.guesses(info = nil); end
  def self.lex(stream, opts = nil, &b); end
  def self.mimetypes(*mts); end
  def self.register(name, lexer); end
  def self.registry; end
  def self.tag(t = nil); end
  def self.title(t = nil); end
  def stream_tokens(stream, &b); end
  def tag; end
  include Rouge::Token::Tokens
end
class InvalidName___Class_0x00___AmbiguousGuess_209 < StandardError
  def alternatives; end
  def initialize(alternatives); end
  def message; end
end
module Rouge::Lexers
  def self.load_lexer(relpath); end
end
class Rouge::RegexLexer < Rouge::Lexer
  def delegate(lexer, text = nil); end
  def get_state(state_name); end
  def goto(state_name); end
  def group(tok); end
  def groups(*tokens); end
  def in_state?(state_name); end
  def pop!(times = nil); end
  def push(state_name = nil, &b); end
  def recurse(text = nil); end
  def reset!; end
  def reset_stack; end
  def self.append(name, &b); end
  def self.get_state(name); end
  def self.prepend(name, &b); end
  def self.replace_state(name, new_defn); end
  def self.start(&b); end
  def self.start_procs; end
  def self.state(name, &b); end
  def self.state_definitions; end
  def self.states; end
  def stack; end
  def state; end
  def state?(state_name); end
  def step(state, stream); end
  def stream_tokens(str, &b); end
  def token(tok, val = nil); end
  def yield_token(tok, val); end
end
class Rouge::RegexLexer::Rule
  def beginning_of_line; end
  def callback; end
  def initialize(re, callback); end
  def inspect; end
  def re; end
end
class Rouge::RegexLexer::State
  def initialize(name, rules); end
  def inspect; end
  def name; end
  def rules; end
end
class Rouge::RegexLexer::StateDSL
  def appended(&defn); end
  def initialize(name, &defn); end
  def load!; end
  def mixin(state); end
  def prepended(&defn); end
  def rule(re, tok = nil, next_state = nil, &callback); end
  def rules; end
  def to_state(lexer_class); end
end
class Rouge::TemplateLexer < Rouge::RegexLexer
  def parent; end
end
class Rouge::Lexers::Scheme < Rouge::RegexLexer
  def self.builtins; end
  def self.keywords; end
end
class Rouge::Lexers::Clojure < Rouge::RegexLexer
  def name_token(name); end
  def self.builtins; end
  def self.keywords; end
end
class Rouge::Lexers::TOML < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Scala < Rouge::RegexLexer
end
class Rouge::Lexers::Groovy < Rouge::RegexLexer
  def self.constants; end
  def self.declarations; end
  def self.keywords; end
  def self.types; end
end
class Rouge::Lexers::Rust < Rouge::RegexLexer
  def macro_closed?; end
  def self.analyze_text(text); end
  def self.builtins; end
  def self.keywords; end
end
class Rouge::Lexers::Praat < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::PHP < Rouge::TemplateLexer
  def builtins; end
  def initialize(opts = nil); end
  def self.analyze_text(text); end
  def self.builtins; end
  def self.keywords; end
  def start_inline?; end
end
class Rouge::Lexers::SQL < Rouge::RegexLexer
  def self.keywords; end
end
class Rouge::Lexers::INI < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Fortran < Rouge::RegexLexer
  def self.intrinsics; end
  def self.keywords; end
  def self.types; end
end
class Rouge::Lexers::Racket < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.builtins; end
  def self.keywords; end
end
class Rouge::Lexers::Haskell < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Julia < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Javascript < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.builtins; end
  def self.constants; end
  def self.declarations; end
  def self.keywords; end
  def self.reserved; end
end
class Rouge::Lexers::JSON < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::JSONDOC < Rouge::Lexers::JSON
end
class Rouge::Lexers::LiterateCoffeescript < Rouge::RegexLexer
  def coffee; end
  def markdown; end
end
class Rouge::Lexers::Qml < Rouge::Lexers::Javascript
end
class Rouge::Lexers::Protobuf < Rouge::RegexLexer
end
class Rouge::Lexers::HTTP < Rouge::RegexLexer
  def content_lexer; end
  def self.http_methods; end
end
class Rouge::Lexers::Actionscript < Rouge::RegexLexer
  def self.builtins; end
  def self.constants; end
  def self.declarations; end
  def self.keywords; end
  def self.reserved; end
end
class Rouge::Lexers::Swift < Rouge::RegexLexer
end
class Rouge::Lexers::Puppet < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.constants; end
  def self.keywords; end
  def self.metaparameters; end
end
class Rouge::Lexers::Markdown < Rouge::RegexLexer
  def html; end
end
class Rouge::Lexers::SassCommon < Rouge::RegexLexer
end
class Rouge::Lexers::Scss < Rouge::Lexers::SassCommon
end
class Rouge::Lexers::Kotlin < Rouge::RegexLexer
end
class Rouge::Lexers::Make < Rouge::RegexLexer
  def initialize(opts = nil); end
  def self.analyze_text(text); end
end
class Rouge::Lexers::Diff < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Factor < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.builtins; end
end
class Rouge::Lexers::Python < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.builtins; end
  def self.builtins_pseudo; end
  def self.exceptions; end
  def self.keywords; end
end
class Rouge::Lexers::Go < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::VimL < Rouge::RegexLexer
  def find_likely_mapping(mapping, word); end
  def mapping_contains?(mapping, word); end
  def self.keywords; end
end
class Rouge::Lexers::CSS < Rouge::RegexLexer
  def self.attributes; end
  def self.builtins; end
  def self.constants; end
  def self.vendor_prefixes; end
end
class Rouge::Lexers::YAML < Rouge::RegexLexer
  def continue_indent(match); end
  def dedent?(level); end
  def indent; end
  def indent?(level); end
  def reset_indent; end
  def save_indent(match); end
  def self.analyze_text(text); end
  def set_indent(match, opts = nil); end
end
class Rouge::Lexers::Pascal < Rouge::RegexLexer
end
class Rouge::Lexers::Nasm < Rouge::RegexLexer
  def self.analyze_text(*arg0); end
  def self.builtins; end
  def self.keywords; end
  def self.keywords_type; end
  def self.reserved; end
end
class Rouge::Lexers::LLVM < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Gradle < Rouge::Lexers::Groovy
  def self.keywords; end
  def self.types; end
end
class Rouge::Lexers::Coffeescript < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.builtins; end
  def self.constants; end
  def self.keywords; end
end
class Rouge::Lexers::Coq < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.classify(x); end
  def self.coq; end
  def self.end_sentence; end
  def self.gallina; end
  def self.keyopts; end
  def self.ltac; end
  def self.tacticals; end
  def self.terminators; end
end
class Rouge::Lexers::CSharp < Rouge::RegexLexer
end
class Rouge::Lexers::C < Rouge::RegexLexer
  def self.analyze_text(*arg0); end
  def self.builtins; end
  def self.keywords; end
  def self.keywords_type; end
  def self.reserved; end
end
class Rouge::Lexers::TCL < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.gen_command_state(name = nil); end
  def self.gen_delimiter_states(name, close, opts = nil); end
end
class Rouge::Lexers::Tap < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Eiffel < Rouge::RegexLexer
end
class Rouge::Lexers::AppleScript < Rouge::RegexLexer
  def self.builtins; end
  def self.classes; end
  def self.commands; end
  def self.controls; end
  def self.declarations; end
  def self.handler_params; end
  def self.literals; end
  def self.operators; end
  def self.references; end
  def self.reserved; end
  def self.studio_classes; end
  def self.studio_commands; end
  def self.studio_events; end
  def self.studio_properties; end
end
class Rouge::Lexers::Elixir < Rouge::RegexLexer
end
class Rouge::Lexers::APIBlueprint < Rouge::Lexers::Markdown
  def self.analyze_text(text); end
end
class Rouge::Lexers::Nginx < Rouge::RegexLexer
end
class Rouge::Lexers::Jinja < Rouge::TemplateLexer
  def self.keywords; end
  def self.pseudo_keywords; end
  def self.tests; end
  def self.word_operators; end
end
class Rouge::Lexers::Twig < Rouge::Lexers::Jinja
  def self.keywords; end
  def self.pseudo_keywords; end
  def self.tests; end
  def self.word_operators; end
end
class Rouge::Lexers::Nim < Rouge::RegexLexer
  def self.underscorize(words); end
end
class Rouge::Lexers::Dart < Rouge::RegexLexer
end
class Rouge::Lexers::D < Rouge::RegexLexer
end
class Rouge::Lexers::Sass < Rouge::Lexers::SassCommon
  include Rouge::Indentation
end
class Rouge::Lexers::Matlab < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.builtins; end
  def self.keywords; end
end
class Rouge::Lexers::Ruby < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::XML < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Cpp < Rouge::Lexers::C
  def self.keywords; end
  def self.keywords_type; end
  def self.reserved; end
end
class Rouge::Lexers::Verilog < Rouge::RegexLexer
  def self.keywords; end
  def self.keywords_system_task; end
  def self.keywords_type; end
end
class Rouge::Lexers::Smarty < Rouge::TemplateLexer
  def self.analyze_text(text); end
  def self.builtins; end
end
class Rouge::Lexers::ERB < Rouge::TemplateLexer
  def initialize(opts = nil); end
  def self.analyze_text(text); end
end
class Rouge::Lexers::ShellSession < Rouge::RegexLexer
end
class Rouge::Lexers::Slim < Rouge::RegexLexer
  def filters; end
  def html; end
  def ruby; end
  include Rouge::Indentation
end
class Rouge::Lexers::Apache < Rouge::RegexLexer
  def name_for_token(token, kwtype, tktype); end
  def self.keywords; end
end
class Rouge::Lexers::Prolog < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Jsonnet < Rouge::RegexLexer
  def self.builtins; end
  def self.constants; end
  def self.declarations; end
  def self.keywords; end
end
class Rouge::Lexers::Ceylon < Rouge::RegexLexer
end
class Rouge::Lexers::Shell < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Powershell < Rouge::Lexers::Shell
end
class Rouge::Lexers::Cfscript < Rouge::RegexLexer
  def self.declarations; end
  def self.keywords; end
  def self.types; end
end
class Rouge::Lexers::Liquid < Rouge::RegexLexer
end
class Rouge::Lexers::Lua < Rouge::RegexLexer
  def builtins; end
  def initialize(opts = nil); end
  def self.analyze_text(text); end
  def self.builtins; end
end
class Rouge::Lexers::Moonscript < Rouge::RegexLexer
  def builtins; end
  def initialize(opts = nil); end
  def self.analyze_text(text); end
end
class Rouge::Lexers::Perl < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Typescript < Rouge::Lexers::Javascript
  def self.builtins; end
  def self.declarations; end
  def self.keywords; end
  def self.reserved; end
end
class Rouge::Lexers::Sed < Rouge::RegexLexer
  def regex; end
  def replacement; end
  def self.analyze_text(text); end
end
class Rouge::Lexers::Sed::Regex < Rouge::RegexLexer
end
class Rouge::Lexers::Sed::Replacement < Rouge::RegexLexer
end
class Rouge::Lexers::CMake < Rouge::RegexLexer
end
class Rouge::Lexers::Smalltalk < Rouge::RegexLexer
end
class Rouge::Lexers::IO < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.builtins; end
  def self.constants; end
end
class Rouge::Lexers::HTML < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::ObjectiveC < Rouge::Lexers::C
  def self.analyze_text(text); end
  def self.at_builtins; end
  def self.at_keywords; end
  def self.builtins; end
end
class Rouge::Lexers::Conf < Rouge::RegexLexer
end
class Rouge::Lexers::Haml < Rouge::RegexLexer
  def filters; end
  def html; end
  def initialize(opts = nil); end
  def ruby; end
  def self.analyze_text(text); end
  include Rouge::Indentation
end
class Rouge::Lexers::Handlebars < Rouge::TemplateLexer
end
class Rouge::Lexers::VisualBasic < Rouge::RegexLexer
  def self.builtins; end
  def self.keywords; end
  def self.keywords_type; end
  def self.operator_words; end
end
class Rouge::Lexers::Erlang < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Tulip < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::OCaml < Rouge::RegexLexer
  def self.keyopts; end
  def self.keywords; end
  def self.primitives; end
  def self.word_operators; end
end
class Rouge::Lexers::LiterateHaskell < Rouge::RegexLexer
  def haskell; end
end
class Rouge::Lexers::Properties < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::TeX < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::R < Rouge::RegexLexer
  def self.analyze_text(text); end
end
class Rouge::Lexers::Java < Rouge::RegexLexer
end
class Rouge::Lexers::Glsl < Rouge::Lexers::C
  def self.builtins; end
  def self.keywords; end
  def self.keywords_type; end
  def self.reserved; end
end
class Rouge::Lexers::CommonLisp < Rouge::RegexLexer
end
class Rouge::Lexers::BIML < Rouge::Lexers::XML
  def self.analyze_text(text); end
end
class Rouge::Lexers::SML < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.keywords; end
  def self.symbolic_reserved; end
  def token_for_final_id(id); end
  def token_for_id(id); end
  def token_for_id_with_dot(id); end
end
class Rouge::Lexers::PlainText < Rouge::Lexer
  def stream_tokens(string, &b); end
  def token; end
end
class Rouge::Lexers::Gherkin < Rouge::RegexLexer
  def self.analyze_text(text); end
  def self.keywords; end
  def self.step_regex; end
end
class Rouge::Formatter
  def format(tokens, &b); end
  def render(tokens); end
  def self.find(tag); end
  def self.format(tokens, opts = nil, &b); end
  def self.tag(tag = nil); end
  def stream(tokens, &b); end
end
module Rouge::Formatters
end
class Rouge::Formatters::HTML < Rouge::Formatter
  def initialize(opts = nil); end
  def span(tok, val); end
  def stream(tokens, &b); end
  def stream_tableized(tokens); end
  def stream_untableized(tokens, &b); end
end
class Rouge::Formatters::Terminal256 < Rouge::Formatter
  def escape_sequence(token); end
  def get_style(token); end
  def initialize(opts = nil); end
  def stream(tokens, &b); end
  def text_style; end
  def theme; end
end
class Rouge::Formatters::Terminal256::EscapeSequence
  def bg; end
  def escape(attrs); end
  def fg; end
  def initialize(style); end
  def reset_string; end
  def self.closest_color(r, g, b); end
  def self.color_index(color); end
  def self.get_rgb(color); end
  def self.xterm_colors; end
  def style; end
  def style_string; end
end
class Rouge::Formatters::Null < Rouge::Formatter
  def initialize(*arg0); end
  def stream(tokens, &b); end
end
class Rouge::Theme
  def palette(*a); end
  def self.base_style; end
  def self.find(n); end
  def self.get_own_style(token); end
  def self.get_style(token); end
  def self.name(n = nil); end
  def self.palette(arg = nil); end
  def self.registry; end
  def self.render(opts = nil, &b); end
  def self.style(*tokens); end
  def self.styles; end
  def styles; end
  include Rouge::Token::Tokens
end
class Rouge::Theme::Style < Hash
  def bg; end
  def fg; end
  def initialize(theme, hsh = nil); end
  def render(selector, &b); end
  def rendered_rules(&b); end
end
module Rouge::HasModes
  def get_mode(mode); end
  def mode!(arg); end
  def mode(arg = nil); end
end
class Rouge::CSSTheme < Rouge::Theme
  def css_selector(token); end
  def inflate_token(tok, &b); end
  def initialize(opts = nil); end
  def render(&b); end
  def render_base(selector, &b); end
  def single_css_selector(token); end
  def style_for(tok); end
end
module Rouge::Themes
end
class Rouge::Themes::ThankfulEyes < Rouge::CSSTheme
end
class Rouge::Themes::Colorful < Rouge::CSSTheme
end
class Rouge::Themes::Base16 < Rouge::CSSTheme
  def self.dark!; end
  def self.light!; end
  def self.make_dark!; end
  def self.make_light!; end
  extend Rouge::HasModes
end
class Rouge::Themes::Base16::Solarized < Rouge::Themes::Base16
end
class Rouge::Themes::Base16::Monokai < Rouge::Themes::Base16
end
class Rouge::Themes::Github < Rouge::CSSTheme
end
class Rouge::Themes::Monokai < Rouge::CSSTheme
end
class Rouge::Themes::Molokai < Rouge::CSSTheme
end
class Rouge::Themes::MonokaiSublime < Rouge::CSSTheme
end
class Rouge::Themes::Gruvbox < Rouge::CSSTheme
  def self.dark!; end
  def self.light!; end
  def self.make_dark!; end
  def self.make_light!; end
  extend Rouge::HasModes
end
